-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Exp.Par
  ( happyError
  , myLexer
  , pModule
  , pExp
  ) where

import Prelude

import qualified Exp.Abs
import Exp.Lex

}

%name pModule Module
%name pExp Exp
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('         { PT _ (TS _ 1)        }
  ')'         { PT _ (TS _ 2)        }
  '*'         { PT _ (TS _ 3)        }
  ','         { PT _ (TS _ 4)        }
  '->'        { PT _ (TS _ 5)        }
  '.1'        { PT _ (TS _ 6)        }
  '.2'        { PT _ (TS _ 7)        }
  ':'         { PT _ (TS _ 8)        }
  ';'         { PT _ (TS _ 9)        }
  '='         { PT _ (TS _ 10)       }
  'Id'        { PT _ (TS _ 11)       }
  'Refl'      { PT _ (TS _ 12)       }
  'U'         { PT _ (TS _ 13)       }
  '\\'        { PT _ (TS _ 14)       }
  'idJ'       { PT _ (TS _ 15)       }
  'in'        { PT _ (TS _ 16)       }
  'let'       { PT _ (TS _ 17)       }
  'module'    { PT _ (TS _ 18)       }
  'where'     { PT _ (TS _ 19)       }
  '{'         { PT _ (TS _ 20)       }
  '}'         { PT _ (TS _ 21)       }
  L_AIdent    { PT _ (T_AIdent _)    }
  L_HoleIdent { PT _ (T_HoleIdent _) }

%%

AIdent :: { Exp.Abs.AIdent }
AIdent  : L_AIdent { Exp.Abs.AIdent (mkPosToken $1) }

HoleIdent :: { Exp.Abs.HoleIdent }
HoleIdent  : L_HoleIdent { Exp.Abs.HoleIdent (mkPosToken $1) }

Module :: { Exp.Abs.Module }
Module
  : 'module' AIdent 'where' '{' ListDecl '}' { Exp.Abs.Module $2 $5 }

Decl :: { Exp.Abs.Decl }
Decl
  : AIdent ListTele ':' Exp '=' Exp { Exp.Abs.DeclDef $1 $2 $4 $6 }

ListDecl :: { [Exp.Abs.Decl] }
ListDecl
  : {- empty -} { [] }
  | Decl { (:[]) $1 }
  | Decl ';' ListDecl { (:) $1 $3 }

Exp :: { Exp.Abs.Exp }
Exp
  : 'let' '{' ListDecl '}' 'in' Exp { Exp.Abs.Let $3 $6 }
  | '\\' AIdent ListAIdent '->' Exp { Exp.Abs.Lam $2 $3 $5 }
  | Exp1 { $1 }

Exp1 :: { Exp.Abs.Exp }
Exp1
  : Exp2 '->' Exp1 { Exp.Abs.Fun $1 $3 }
  | Tele ListTele '->' Exp1 { Exp.Abs.Pi $1 $2 $4 }
  | Tele ListTele '*' Exp1 { Exp.Abs.Sigma $1 $2 $4 }
  | Exp2 { $1 }

Exp2 :: { Exp.Abs.Exp }
Exp2 : Exp2 Exp3 { Exp.Abs.App $1 $2 } | Exp3 { $1 }

Exp3 :: { Exp.Abs.Exp }
Exp3
  : 'Id' Exp4 Exp4 Exp3 { Exp.Abs.Id $2 $3 $4 }
  | 'idJ' Exp4 Exp4 Exp4 Exp4 Exp4 Exp4 { Exp.Abs.IdJ $2 $3 $4 $5 $6 $7 }
  | 'Refl' Exp4 Exp4 { Exp.Abs.Refl $2 $3 }
  | Exp4 { $1 }

Exp4 :: { Exp.Abs.Exp }
Exp4
  : Exp4 '.1' { Exp.Abs.Fst $1 }
  | Exp4 '.2' { Exp.Abs.Snd $1 }
  | Exp5 { $1 }

Exp5 :: { Exp.Abs.Exp }
Exp5
  : '(' Exp ',' ListExp ')' { Exp.Abs.Pair $2 $4 }
  | AIdent { Exp.Abs.Var $1 }
  | 'U' { Exp.Abs.U }
  | HoleIdent { Exp.Abs.Hole $1 }
  | '(' Exp ')' { $2 }

ListExp :: { [Exp.Abs.Exp] }
ListExp : Exp { (:[]) $1 } | Exp ',' ListExp { (:) $1 $3 }

Tele :: { Exp.Abs.Tele }
Tele : '(' AIdent ListAIdent ':' Exp ')' { Exp.Abs.Tele $2 $3 $5 }

ListTele :: { [Exp.Abs.Tele] }
ListTele : {- empty -} { [] } | Tele ListTele { (:) $1 $2 }

ListAIdent :: { [Exp.Abs.AIdent] }
ListAIdent : {- empty -} { [] } | AIdent ListAIdent { (:) $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

